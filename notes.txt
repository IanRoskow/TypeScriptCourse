Section 2
Why do we care abour types
-Helps analyze for errors
-Helps other engineers understand our codebase

Where do we use types... Everywhere!

Section 3
Annotations 
-We the developer tell TS the type

Inference
-TS guesses the type

We will be using Inference for all cases except the following:
1) Function that returns the 'any' type i.e. JSON.parse();
2) Delayed initialization
3) When the vaiable type can not be inferred, corner case


Section 4
Annotations with functions and objects

No type inference on aurguments for functions, only type inference from return but we do not use it
We will always annotate the return to ensure we require the return

Section 5
Typed Arrays

Section 6
Tuples

Using an ordered array in place of an object, tends to be better to just use objects

Section 7
Do not overly annotate functions and interfaces. Keep things generic and robust.

General strategy for reusable code in TS
-Create functions that accept arguments that are typed with interfaces
-Objects/classes can decide to 'implement' that interface

Senpction 8
Classes - blueprint to create object with values and functions

Marking methods as Private does not add application security
It only restricts which developers can use it.

Section 9 
Design Patterns with Typescript

Even if you are using a library or api's like google maps, you can hide functionality by using a private class and only exposing the private methods you have vetted.

When you use the OR | when defining types in a class, it will only let you reference the common properties on those objects.
This should not be the approach because it is not scalable and is introducing tight coupling.
Should use interfaces to flip the dependency. Tell all casses what they need to be an argument to a class.
Interfaces are the gate keepers to the classes, prelabels to see if properties apply.